use std::{
    collections::HashMap,
    fs::{self, File},
    io::Write,
    marker::PhantomData,
    path::{Path, PathBuf},
    sync::Arc,
};

use serde_json::Value;
use specta::{to_ts, to_ts_export, DataType, TypeDefs};

use crate::{ExecError, ExportError, OperationKey, OperationKind, Procedure, StreamOrValue};

pub struct Router<TCtx = (), TMeta = ()>
where
    TCtx: 'static,
{
    pub(crate) queries: HashMap<String, Procedure<TCtx>>,
    pub(crate) mutations: HashMap<String, Procedure<TCtx>>,
    pub(crate) subscriptions: HashMap<String, Procedure<TCtx>>,
    pub(crate) typ_store: TypeDefs,
    pub(crate) phantom: PhantomData<TMeta>,
}

impl<TCtx, TMeta> Router<TCtx, TMeta>
where
    TCtx: 'static,
{
    pub async fn exec(
        &self,
        ctx: TCtx,
        kind: OperationKind,
        key: OperationKey,
    ) -> Result<StreamOrValue, ExecError> {
        // TODO: This function should return either a stream or a value based on the `OperationKind` not an enum that could be both!
        // TODO: Reduce cloning in this function!
        match kind {
            OperationKind::Query => {
                (self
                    .queries
                    .get(&*key.0)
                    .ok_or(ExecError::OperationNotFound(key.0.clone()))?
                    .exec)(
                    ctx,
                    key.1.clone().unwrap_or(Value::Null),
                    (OperationKind::Query, key),
                )?
                .into_stream_or_value()
                .await
            }
            OperationKind::Mutation => {
                (self
                    .mutations
                    .get(&*key.0)
                    .ok_or(ExecError::OperationNotFound(key.0.clone()))?
                    .exec)(
                    ctx,
                    key.1.clone().unwrap_or(Value::Null),
                    (OperationKind::Mutation, key),
                )?
                .into_stream_or_value()
                .await
            }
            OperationKind::SubscriptionAdd => {
                (self
                    .subscriptions
                    .get(&*key.0)
                    .ok_or(ExecError::OperationNotFound(key.0.clone()))?
                    .exec)(
                    ctx,
                    key.1.clone().unwrap_or(Value::Null),
                    (OperationKind::SubscriptionAdd, key),
                )?
                .into_stream_or_value()
                .await
            }
            OperationKind::SubscriptionRemove => todo!(),
        }
    }

    pub fn arced(self) -> Arc<Self> {
        Arc::new(self)
    }

    pub fn queries(&self) -> &HashMap<String, Procedure<TCtx>> {
        &self.queries
    }

    pub fn mutations(&self) -> &HashMap<String, Procedure<TCtx>> {
        &self.mutations
    }

    pub fn subscriptions(&self) -> &HashMap<String, Procedure<TCtx>> {
        &self.subscriptions
    }

    pub fn typ_store(&self) -> TypeDefs {
        self.typ_store.clone()
    }

    pub fn export_ts<TPath: AsRef<Path>>(&self, export_path: TPath) -> Result<(), ExportError> {
        let export_path = PathBuf::from(export_path.as_ref());
        if let Some(export_dir) = export_path.parent() {
            fs::create_dir_all(export_dir)?;
        }
        let mut file = File::create(export_path)?;
        writeln!(file, "// This file was generated by [rspc](https://github.com/oscartbeaumont/rspc). Do not edit this file manually.")?;

        println!("{:#?}", &self.typ_store);
        println!(
            "{:#?}",
            &self
                .queries
                .iter()
                .map(|(k, v)| (k, &v.ty))
                .collect::<HashMap<_, _>>()
        );

        let queries_ts = generate_procedures_ts(&self.queries);
        let mutations_ts = generate_procedures_ts(&self.mutations);
        let subscriptions_ts = generate_procedures_ts(&self.subscriptions);

        writeln!(
            file,
            r#"
export type Operations = {{
    queries: {queries_ts},
    mutations: {mutations_ts},
    subscriptions: {subscriptions_ts}
}};"#
        )?;

        for export in self.typ_store.values().filter_map(|v| to_ts_export(v).ok()) {
            writeln!(file, "\n{}", export)?;
        }

        Ok(())
    }
}

fn generate_procedures_ts<Ctx>(procedures: &HashMap<String, Procedure<Ctx>>) -> String {
    match procedures.len() {
        0 => "never".to_string(),
        _ => procedures
            .iter()
            .map(|(key, operation)| {
                let arg_ts = match &operation.ty.arg_ty {
                    DataType::Tuple(def)
                        // This condition is met with an empty enum or `()`.
                        if def.fields.len() == 0 =>
                    {
                        "".into()
                    }
                    ty => format!(", {}", to_ts(ty)),
                };
                let result_ts = to_ts(&operation.ty.result_ty);

                format!(
                    r#"
        {{ key: ["{key}"{arg_ts}], result: {result_ts} }}"#
                )
            })
            .collect::<Vec<_>>()
            .join(" | "),
    }
}
