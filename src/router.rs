use std::{
    collections::BTreeMap,
    fs::{self, File},
    io::Write,
    marker::PhantomData,
    path::{Path, PathBuf},
    sync::Arc,
};

use futures::Stream;
use serde_json::Value;
use specta::{to_ts, to_ts_export, DataType, TypeDefs};

use crate::{
    internal::{Procedure, ProcedureKind, ProcedureStore, RequestContext},
    Config, ExecError, ExportError,
};

/// TODO
pub struct Router<TCtx = (), TMeta = ()>
where
    TCtx: 'static,
{
    pub(crate) config: Config,
    pub(crate) queries: ProcedureStore<TCtx>,
    pub(crate) mutations: ProcedureStore<TCtx>,
    pub(crate) subscriptions: ProcedureStore<TCtx>,
    pub(crate) typ_store: TypeDefs,
    pub(crate) phantom: PhantomData<TMeta>,
}

// TODO: Move this out of this file
// TODO: Rename??
pub enum ExecKind {
    Query,
    Mutation,
}

impl<TCtx, TMeta> Router<TCtx, TMeta>
where
    TCtx: 'static,
{
    pub async fn exec(
        &self,
        ctx: TCtx,
        kind: ExecKind,
        key: String,
        input: Option<Value>,
    ) -> Result<Value, ExecError> {
        let (operations, kind) = match kind {
            ExecKind::Query => (&self.queries.store, ProcedureKind::Query),
            ExecKind::Mutation => (&self.mutations.store, ProcedureKind::Mutation),
        };

        operations
            .get(&key)
            .ok_or_else(|| ExecError::OperationNotFound(key.clone()))?
            .exec
            .call(
                ctx,
                input.unwrap_or(Value::Null),
                RequestContext { kind, path: key },
            )?
            .into_value()
            .await
    }

    pub async fn exec_subscription(
        &self,
        ctx: TCtx,
        key: String,
        input: Option<Value>,
    ) -> Result<Box<dyn Stream<Item = Value>>, ExecError> {
        // operations
        //     .get(&key)
        //     .ok_or_else(|| ExecError::OperationNotFound(key.clone()))?
        //     .exec
        //     .call(
        //         ctx,
        //         input.unwrap_or(Value::Null),
        //         RequestContext { kind, path: key },
        //     )?
        //     .into_value()
        //     .await;

        todo!()
    }

    /// TODO: Docs
    // pub async fn execute(
    //     &self,
    //     ctx: TCtx,
    //     kind: T,
    //     key: String,
    //     input: Option<Value>,
    //     // TODO: Use T::Result
    // ) -> Result<Value, ExecError> {
    //     // Request {
    //     //     jsonrpc: None,
    //     //     id: RequestId::Null,
    //     //     inner: match T::KIND {
    //     //         OperationKind::Query => RequestInner::Query { path: key, input },
    //     //         OperationKind::Mutation => RequestInner::Mutation { path: key, input },
    //     //         OperationKind::Subscription => todo!(),
    //     //     },
    //     // }
    //     // .execute(self, ctx)
    //     // .await
    //     todo!();
    // }

    pub fn arced(self) -> Arc<Self> {
        Arc::new(self)
    }

    pub fn typ_store(&self) -> TypeDefs {
        self.typ_store.clone()
    }

    pub fn queries(&self) -> &BTreeMap<String, Procedure<TCtx>> {
        &self.queries.store
    }

    pub fn mutations(&self) -> &BTreeMap<String, Procedure<TCtx>> {
        &self.mutations.store
    }

    pub fn subscriptions(&self) -> &BTreeMap<String, Procedure<TCtx>> {
        &self.subscriptions.store
    }

    pub fn export_ts<TPath: AsRef<Path>>(&self, export_path: TPath) -> Result<(), ExportError> {
        let export_path = PathBuf::from(export_path.as_ref());
        if let Some(export_dir) = export_path.parent() {
            fs::create_dir_all(export_dir)?;
        }
        let mut file = File::create(export_path)?;
        if let Some(header) = &self.config.bindings_header {
            writeln!(file, "{}", header)?;
        }
        writeln!(file, "// This file was generated by [rspc](https://github.com/oscartbeaumont/rspc). Do not edit this file manually.")?;

        let queries_ts = generate_procedures_ts(&self.queries.store);
        let mutations_ts = generate_procedures_ts(&self.mutations.store);
        let subscriptions_ts = generate_procedures_ts(&self.subscriptions.store);

        // TODO: Specta API
        writeln!(
            file,
            r#"
export type Procedures = {{
    queries: {queries_ts},
    mutations: {mutations_ts},
    subscriptions: {subscriptions_ts}
}};"#
        )?;

        for export in self.typ_store.values().filter_map(|v| to_ts_export(v).ok()) {
            writeln!(file, "\n{}", export)?;
        }

        Ok(())
    }
}

// impl<TCtx, TMeta> RequestRouter for Router<TCtx, TMeta> {
//     type Ctx = TCtx;

//     fn queries(&self) -> &BTreeMap<String, Procedure<TCtx>> {
//         &self.queries.store
//     }

//     fn mutations(&self) -> &BTreeMap<String, Procedure<TCtx>> {
//         &self.mutations.store
//     }

//     fn subscriptions(&self) -> &BTreeMap<String, Procedure<TCtx>> {
//         &self.subscriptions.store
//     }
// }

// TODO: Move this out into a Specta API
fn generate_procedures_ts<Ctx>(procedures: &BTreeMap<String, Procedure<Ctx>>) -> String {
    match procedures.len() {
        0 => "never".to_string(),
        _ => procedures
            .iter()
            .map(|(key, operation)| {
                let input = match &operation.ty.arg_ty {
                    DataType::Tuple(def)
                        // This condition is met with an empty enum or `()`.
                        if def.fields.len() == 0 =>
                    {
                        "never".into()
                    }
                    ty => to_ts(ty),
                };
                let result_ts = to_ts(&operation.ty.result_ty);

                // TODO: Specta API
                format!(
                    r#"
        {{ key: "{key}", input: {input}, result: {result_ts} }}"#
                )
            })
            .collect::<Vec<_>>()
            .join(" | "),
    }
}
